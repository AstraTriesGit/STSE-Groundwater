---
title: "R Notebook"
output: pdf_document
---

Load the dang data.
```{r}
library(dplyr)
library(fields)
library(ggplot2)
library(gstat)
library(RColorBrewer)
library(sp)
library(spacetime)
library(devtools)
library(feather)
library(raster)
library(STRbook)

d1 <- read_feather('data/premonsoon_monsoon.feather')
d2 <- read_feather('data/premonsoon_postmonsoon.feather')
d3 <- read_feather('data/full_monsoon.feather')
```
What are you waiting for? DO IT!
```{r}
perform_rbf <- function(data, time_point, bandwidth = 0.1, resolution = 0.01) {
  # Filter data for the specific time point
  data_at_time <- data[data$data_time == time_point,]

  # Create a spatial points dataframe
  coordinates(data_at_time) <- ~longitude+latitude

  # Define the grid for interpolation
  # Extend the grid slightly beyond the data points
  grid_extent <- extent(
    min(data$longitude) - 0.1,
    max(data$longitude) + 0.1,
    min(data$latitude) - 0.1,
    max(data$latitude) + 0.1
  )

  grid <- raster(grid_extent, resolution = resolution)
  grid_points <- rasterToPoints(grid, spatial = TRUE)

  # Create the variogram model with Gaussian kernel
  # The Gaussian kernel in gstat is achieved by using the 'Gau' model
  vgm_model <- gstat(
    formula = data_value ~ 1,
    locations = data_at_time,
    model = vgm(psill = 1, model = "Gau", range = bandwidth),
    nmax = 12  # Maximum number of nearest neighbors to consider
  )

  # Predict values at grid points
  prediction <- predict(vgm_model, grid_points)

  # Convert prediction to raster
  rbf_raster <- rasterize(prediction, grid, field = "var1.pred")

  return(list(
    raster = rbf_raster,
    prediction = prediction,
    time = time_point
  ))
}

# Convert data_time to POSIXct if it's not already
if(!inherits(d1$data_time, "POSIXct")) {
  d1$data_time <- as.POSIXct(d1$data_time)
}

# 2. Select a specific time point for interpolation
# For example, the first time point in the dataset
time_point <- unique(d1$data_time)[1]

# 3. Perform Gaussian RBF interpolation
rbf_result <- perform_rbf(d1, time_point, bandwidth = 0.1)

raster_df <- as.data.frame(rasterToPoints(rbf_result$raster))
colnames(raster_df) <- c("longitude", "latitude", "value")

# Sample points data for plotting
points_df <- d1[d1$data_time == time_point, c("longitude", "latitude", "data_value")]

# Define arbitrary points to mark on the map
arbitrary_points <- data.frame(
  longitude = 73,  # Example coordinates - replace with your desired points
  latitude = 27.5       # Example coordinates - replace with your desired points
)

# Plot
ggplot() +
  geom_raster(data = raster_df, aes(x = longitude, y = latitude, fill = value)) +
  geom_contour(data = raster_df, aes(x = longitude, y = latitude, z = value),
               color = "black", alpha = 0.5, bins = 8) +  # Add contour lines
  geom_point(data = points_df, aes(x = longitude, y = latitude),
             color = "black", size = 0.5, shape = 21, fill = "white") +
  # Add arbitrary points with distinctive appearance
  geom_point(data = arbitrary_points, aes(x = longitude, y = latitude),
             color = "blue", size = 4, shape = 23, fill = "yellow") +
  scale_fill_viridis_c(name = "Interpolated Value", option = "plasma") +
  theme_bw() +  # Use theme_bw() for a non-transparent white background
  theme(
    panel.background = element_rect(fill = "white", color = "black"),  # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    legend.background = element_rect(fill = "white", color = NA)  # White legend background
  ) +
  labs(
    title = paste("Gaussian Radial Basis Function Interpolation"),
    subtitle = paste("Time:", format(rbf_result$time)),
    x = "Longitude",
    y = "Latitude"
  )

ggsave('plots/gaussian_d1.png', dpi = 300)
```