---
title: "Updated OLS Regression Using Categorical Variables"
output: pdf_document
---

For more information on how we obtained the balanced panel, kindly refer to `exploratory/filtered_panel.rmd`.
```{r}
# install.packages(c('readr', 'gstat', 'spacetime', 'sp', 'xts', 'fields', 'stargazer', 'ggplot2', 'maps'))

library(readr)
library(maps)
library(ggplot2)
library(dplyr)
library(lubridate)
library(stargazer)
library(gstat)
library(xts)
library(sp)
library(spacetime)
library(ape)
library(lmtest)
library(tidyr)
library(purrr)

gwl_panel <- read_csv("data/year_panel.csv")
```


# Model Specification
We will be adding the following categorical/dummy variables to our existing analysis:
- `monsoon(s, t)` = 1 if `t` falls in the range June-September, 0 otherwise.
- `indo_gangetic(s, t)` = 1 if `s` falls in the Indo-Gangetic region, 0 otherwise
- `north_east(s, t)` = 1 if `s` falls in North-East India, 0 otherwise
- `deccan(s, t)` = 1 if `s` falls in the Deccan plateau, 0 otherwise
A visualisation will help us find the relevant locations, as well as find the coordinates that
we will use to assign dummy variable values.
```{r}

plot_roi <- function(gwl_panel) {
  india_map <- map_data("world") %>%
    filter(region == "India")

  ggplot() +
    labs(title = "Regions of Interest") +
    geom_polygon(data = india_map,
                 aes(x = long, y = lat, group = group),
                 color = "black", alpha = 0, size = 0.1) +
    geom_point(data = gwl_panel,
               aes(x = longitude, y = latitude), size = 0.5) +
    geom_rect(aes(xmin = 90, xmax = 96, ymin = 22, ymax = 28),
              fill = NA, color = "red", size = 0.5, alpha = 0) +
    geom_rect(aes(xmin = 73.50, xmax = 89.49, ymin = 23.5, ymax = 31.28),
              fill = NA, color = "red", size = 0.5, alpha = 0) +
    geom_rect(aes(xmin = 77, xmax = 81, ymin = 15, ymax = 20),
              fill = NA, color = "red", size = 0.5, alpha = 0) +
    annotate("text", x = 93, y = 28.5, label = "North-East Region",
             color = "red", size = 4, fontface = "bold") +
    annotate("text", x = 81.495, y = 32, label = "Indo-Gangetic Region",
             color = "red", size = 4, fontface = "bold") +
    annotate("text", x = 79, y = 20.5, label = "Deccan Region",
             color = "red", size = 4, fontface = "bold") +
    theme(plot.title = element_text(size = 20, hjust = 0.5),
          axis.title.x = element_text(size = 18),
          axis.title.y = element_text(size = 18),
          axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size = 10))
}

plot_roi(gwl_panel)
# ggsave("plots/roi_all.png", dpi = 150)
```


We will now add the required variables for our regression analysis, followed by a call to `lm`. Finally, we append
the residuals to the dataframe used in the regression for further analysis.
```{r}
#' Returns true if the coordinates of a place (x, y) lie within a given region.
within_region <- function (x, y, region) {
  return ((x >= region$xmin & x <= region$xmax & y >= region$ymin & y <= region$ymax))
}

#' Adds the required dummy variables for the analysis
add_dummy_variables <- function(gwl_panel) {
  # regions to model for
  ne <- data.frame(xmin = 90, xmax = 96, ymin = 22, ymax = 28)
  indo_g <- data.frame(xmin = 73.50, xmax = 89.49, ymin = 23.5, ymax = 31.28)
  deccan_plateau <- data.frame(xmin = 77, xmax = 81, ymin = 15, ymax = 20)

  # actual mutation routine
  df <- gwl_panel %>%
    rename(x = longitude, y = latitude, time = data_time) %>%
    mutate(time = as.numeric(month(floor_date(time, unit = "month"))),
           long_time = x * time,
           lat_time = y * time,
           lat_long = x * y,
           monsoon = as.numeric(time <= 9 & time >= 6),
           indo_gangetic = as.numeric(within_region(x, y, indo_g)),
           north_east = as.numeric(within_region(x, y, ne)),
           deccan = as.numeric(within_region(x, y, deccan_plateau))
    )

  return (df)
}

df <- add_dummy_variables(gwl_panel)
ols_model <- lm(reading ~ y + x + lat_time + long_time + lat_long + time +
  monsoon + indo_gangetic + north_east + deccan,
                data = df)

summary(ols_model)

# calls to stargazer for tables used in presentation
# stargazer(ols_model, type = "text",
#           title = "OLS Regression Model Statistics", omit.stat = "all", report = "vcs*")
# stargazer(ols_model, type = "latex",
#           title = "OLS Regression Model Statistics", coef = NULL, p.auto = FALSE)
#
# stargazer(ols_model,
#           title = "Alternate OLS Regression Model Statistics",
#           omit.table.layout = "n",
#           type = "text")

df$residuals <- ols_model$residuals
```


# Residuals Visualisation Over Space And Time
Time to visualise the residuals. The following code will plot the residuals in space, chosen over 4 distinct months.
```{r}
plot_residuals_over_space <- function(df) {
  # choosing four different months, ideally equally spaced
  df_chosen_times <- df %>%
    filter(month(time) %in% c(5, 9, 11, 3))

  india_map <- map_data("world") %>%
    filter(region == "India")

  ggplot() +
    geom_polygon(data = india_map,
                 aes(x = long, y = lat, group = group),
                 color = "black", alpha = 0, size = 0.1) +
    geom_point(data = df_chosen_times,
               aes(x = x, y = y, color = residuals),
               size = 0.15) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
    coord_fixed(1.3) +
    labs(title = "Spatial Plot of OLS Residuals over Months",
         x = "Longitude",
         y = "Latitude") +
    facet_wrap(~time, nrow = 1) +
    theme(plot.title = element_text(size = 20, hjust = 0.5),
          axis.title.x = element_text(size = 18),
          axis.title.y = element_text(size = 18),
          axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size = 10),
          legend.title = element_text(size = 18),
          legend.text = element_text(size = 10),
          strip.text = element_text(size = 18),
          plot.margin = margin(0, 0, 0, 0))
}

plot_residuals_over_space(df)
# ggsave('plots/ols_space_residuals.png', dpi = 150)
```


The following code will select two random locations and plot the residuals of those locations over time.
```{r}
plot_residuals_over_time <- function(df) {
  sample_size <- 2
  random_indices <- sample(seq_len(nrow(df)), size = sample_size)
  random_latlong <- df[random_indices, c("y", "x")]

  df_chosen_locations <- df %>%
    inner_join(random_latlong, by = c("y", "x"))

  df_location_1 <- df_chosen_locations %>%
    filter(x == random_latlong$x[1])
  df_location_2 <- df_chosen_locations %>%
    filter(x == random_latlong$x[2])

  ggplot(df_location_1, aes(x = time, y = residuals)) +
    geom_line() +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(
      x = "Time",
      y = "Residuals",
      title = "Time Series Plot of OLS Residuals at Random Locations"
    ) + geom_line(data = df_location_2, mapping = aes(x = time, y = residuals)) +
    theme_bw() +
    theme(plot.title = element_text(size = 20, hjust = 0.5),
          axis.title.x = element_text(size = 18),
          axis.title.y = element_text(size = 18),
          axis.text.x = element_text(size = 15),
          axis.text.y = element_text(size = 15),
          legend.title = element_text(size = 18),
          legend.text = element_text(size = 10),
          strip.text = element_text(size = 18),
          plot.margin = margin(0, 0, 0, 0))
}
plot_residuals_over_time(df)

# ggsave('plots/ols_time_residuals.png', dpi = 150)
```

# Variogram Analysis
To use R's variogram tools, we first need to convert our data into a spatio-temporal data object. We will be using the
STFDF object from the `spacetime` package. (spatio-temporal object with a full spacetime grid, which is ensured with our panel.)
```{r}
convert_to_stfdf <- function(df) {
  coords <- df %>%
          group_by(x, y) %>%
          summarise()
  coords <- cbind(coords$x, coords$y)
  sp_obj <- SpatialPoints(coords)

  df <- df %>% mutate(timestamp = gwl_panel$data_time)
  dates <- df$timestamp
  dates <- unique(dates)
  time_obj <- xts(1:12, order.by=dates)

  obs_data <- data.frame(
          reading = df$reading,
          residuals = df$residuals
  )
  stfdf_obj <- STFDF(sp = sp_obj, time = time_obj, data = obs_data)

  # tell R that the coords are in lat/long format + set datum to WGS84
  proj4string(stfdf_obj) <- CRS("+proj=longlat +datum=WGS84 +no_defs")

  # setting the coord reference system to India National Grid (Lambert Conformal Conic) (Designed for all of India)
  stfdf_proj <- spTransform(stfdf_obj, CRS("EPSG:7755"))

  return (stfdf_proj)
}

stfdf_proj <- convert_to_stfdf(df)
summary(stfdf_proj)
```

Once we have our (properly configured, see setting of CRS) STFDF object,
we can now use the `variogram` function in the `gstat` package to conduct our
analyses on the data and residual variograms.
```{r}
var_residuals <- variogram(object = residuals~1,
                           data = stfdf_proj,
                           width = 5000,     # 5 km bins
                           cutoff = 200000,  # 200 km maximum
                           tlags = 0:11)
var_og <- variogram(object = reading~1,
                           data = stfdf_proj,
                           width = 5000,     # 5 km bins
                           cutoff = 200000,  # 200 km maximum
                           tlags = 0:11)
```

The following code will plot the spatial variogram.
```{r}
plot_spatial_variograms <- function(var_residuals, var_og) {
  # Extract spatial variogram (time lag = 0) from both variograms
  spatial_var_residuals <- var_residuals[var_residuals$timelag == 0, ]
  spatial_var_og <- var_og[var_og$timelag == 0, ]

  ggplot() +
          geom_point(data = spatial_var_og, aes(x = dist, y = gamma, color = "Original Data")) +
          geom_line(data = spatial_var_og, aes(x = dist, y = gamma, color = "Original Data")) +
          geom_point(data = spatial_var_residuals, aes(x = dist, y = gamma, color = "Residuals")) +
          geom_line(data = spatial_var_residuals, aes(x = dist, y = gamma, color = "Residuals")) +
          scale_color_manual(values = c("Original Data" = "blue", "Residuals" = "red")) +
          scale_x_continuous(labels = function(x) x/1000) +  # Convert to km on axis
          labs(x = "Distance (km)", y = "Semivariance",
               title = "Spatial Variograms",
               color = "Data Type") +
          theme_bw() +
          theme(plot.title = element_text(size = 20, hjust = 0.5),
                axis.title.x = element_text(size = 18),
                axis.title.y = element_text(size = 18),
                axis.text.x = element_text(size = 15),
                axis.text.y = element_text(size = 15),
                legend.title = element_text(size = 18),
                legend.text = element_text(size = 12),
                strip.text = element_text(size = 18),
                plot.margin = margin(0, 0, 0, 0))
}

plot_spatial_variograms(var_residuals, var_og)
# ggsave('plots/sp_variogram.png', dpi = 150)
```

Similarly, we can plot the temporal variogram.
```{r}
plot_temporal_variograms <- function(var_og, var_residuals) {
  # Extract temporal variogram (typically using the smallest distance bin)
  min_dist <- min(var_residuals$dist, na.rm = TRUE)

  # Extract temporal variogram for residuals and original data
  temporal_var_residuals <- var_residuals[var_residuals$dist == min_dist, ]
  temporal_var_og <- var_og[var_og$dist == min_dist, ]

  # Plot the temporal variograms
  ggplot() +
          geom_point(data = temporal_var_og, aes(x = timelag, y = gamma, color = "Original Data")) +
          geom_line(data = temporal_var_og, aes(x = timelag, y = gamma, color = "Original Data")) +
          geom_point(data = temporal_var_residuals, aes(x = timelag, y = gamma, color = "Residuals")) +
          geom_line(data = temporal_var_residuals, aes(x = timelag, y = gamma, color = "Residuals")) +
          scale_color_manual(values = c("Original Data" = "blue", "Residuals" = "red")) +
          labs(x = "Time Lag", y = "Semivariance",
               title = "Temporal Variograms",
               color = "Data Type") +
          theme_bw() +
          theme(plot.title = element_text(size = 20, hjust = 0.5),
                axis.title.x = element_text(size = 18),
                axis.title.y = element_text(size = 18),
                axis.text.x = element_text(size = 15),
                axis.text.y = element_text(size = 15),
                legend.title = element_text(size = 18),
                legend.text = element_text(size = 12),
                strip.text = element_text(size = 18),
                plot.margin = margin(0, 0, 0, 0))
}

plot_temporal_variograms(var_og, var_residuals)
# ggsave('plots/t_variogram.png', dpi = 150)
```

# Statistical Testing
The following code will now produce the results of the tests we showed to prove certain properties of the data.
We will start off with the spatial Moran's I test. Note that we do not need the STFDF object here.
```{r}
# Moran's I test
conduct_morans_I <- function(df) {
  P <- list()
  unique_dates <- unique(df$time)
  for(i in unique_dates) {
    gwl_month <- filter(df, df$time == i)
    station.dists <- gwl_month %>%
            select(x, y) %>%
            dist() %>%
            as.matrix()

    station.dists.inv <- 1/station.dists
    diag(station.dists.inv) <- 0 #

    P[[i]] <- Moran.I(gwl_month$residuals, station.dists.inv) %>%
            do.call("cbind", .)
  }

  P <- do.call("rbind", P)
  P <- as.data.frame(P)

  return (P)
}

P <- conduct_morans_I(df)
summary(P)
```


This will be followed by the Durbin-Watson autocorrelation test.
```{r}
# Durbin-Watson Test
conduct_dwtest <- function(df) {
  nested_gwl <- group_by(df, x, y) %>% nest()
  dwtest_one_station <- function(data)
          dwtest(residuals ~ 1, data = data)
  map(nested_gwl$data, dwtest_one_station) %>% head()

  gwl_DW <- nested_gwl %>%
          mutate(dw_test = map(data, dwtest_one_station)) %>%
          mutate(dw_statistic = map_dbl(dw_test, ~.$statistic),
                 dw_pvalue = map_dbl(dw_test, ~.$p.value))

  return (gwl_DW)
}

gwl_DW <- conduct_dwtest(df)
```
